@_exported import Foundation
@_exported import UIKit.DocumentManager
import UIKit.NSAttributedString
import UIKit.NSDataAsset
import UIKit.NSDiffableDataSourceSectionSnapshot
import UIKit.NSFileProviderExtension
import UIKit.NSIndexPath_UIKitAdditions
import UIKit.NSItemProvider_UIKitAdditions
import UIKit.NSLayoutAnchor
import UIKit.NSLayoutConstraint
import UIKit.NSLayoutManager
import UIKit.NSParagraphStyle
import UIKit.NSShadow
import UIKit.NSStringDrawing
import UIKit.NSText
import UIKit.NSTextAttachment
import UIKit.NSTextContainer
import UIKit.NSTextStorage
import UIKit.NSToolbar_UIKitAdditions
import UIKit.NSTouchBar_UIKitAdditions
import UIKit.NSUserActivity_NSItemProvider
@_exported import UIKit.ShareSheet
import UIKit.UIAccelerometer
import UIKit.UIAccessibility
import UIKit.UIAccessibilityAdditions
import UIKit.UIAccessibilityConstants
import UIKit.UIAccessibilityContainer
import UIKit.UIAccessibilityContentSizeCategoryImageAdjusting
import UIKit.UIAccessibilityCustomAction
import UIKit.UIAccessibilityCustomRotor
import UIKit.UIAccessibilityElement
import UIKit.UIAccessibilityIdentification
import UIKit.UIAccessibilityLocationDescriptor
import UIKit.UIAccessibilityZoom
import UIKit.UIAction
import UIKit.UIActionSheet
import UIKit.UIActivity
import UIKit.UIActivityIndicatorView
import UIKit.UIActivityItemProvider
import UIKit.UIActivityItemsConfiguration
import UIKit.UIActivityItemsConfigurationReading
import UIKit.UIActivityViewController
import UIKit.UIAlert
import UIKit.UIAlertController
import UIKit.UIAlertView
import UIKit.UIAppearance
import UIKit.UIApplication
import UIKit.UIApplicationShortcutItem
import UIKit.UIAttachmentBehavior
import UIKit.UIBackgroundConfiguration
import UIKit.UIBarAppearance
import UIKit.UIBarButtonItem
import UIKit.UIBarButtonItemAppearance
import UIKit.UIBarButtonItemGroup
import UIKit.UIBarCommon
import UIKit.UIBarItem
import UIKit.UIBezierPath
import UIKit.UIBlurEffect
import UIKit.UIButton
import UIKit.UICellAccessory
import UIKit.UICellConfigurationState
import UIKit.UICloudSharingController
import UIKit.UICollectionLayoutList
import UIKit.UICollectionView
import UIKit.UICollectionViewCell
import UIKit.UICollectionViewCompositionalLayout
import UIKit.UICollectionViewController
import UIKit.UICollectionViewFlowLayout
import UIKit.UICollectionViewItemRegistration
import UIKit.UICollectionViewLayout
import UIKit.UICollectionViewListCell
import UIKit.UICollectionViewTransitionLayout
import UIKit.UICollectionViewUpdateItem
import UIKit.UICollisionBehavior
import UIKit.UIColor
import UIKit.UIColorPickerViewController
import UIKit.UIColorWell
import UIKit.UICommand
import UIKit.UIConfigurationColorTransformer
import UIKit.UIConfigurationState
import UIKit.UIContentConfiguration
import UIKit.UIContentSizeCategory
import UIKit.UIContentSizeCategoryAdjusting
import UIKit.UIContextMenuConfiguration
import UIKit.UIContextMenuInteraction
import UIKit.UIContextualAction
import UIKit.UIControl
import UIKit.UIDataDetectors
import UIKit.UIDataSourceTranslating
import UIKit.UIDatePicker
import UIKit.UIDeferredMenuElement
import UIKit.UIDevice
import UIKit.UIDiffableDataSource
import UIKit.UIDocument
import UIKit.UIDocumentBrowserAction
import UIKit.UIDocumentBrowserViewController
import UIKit.UIDocumentInteractionController
import UIKit.UIDocumentMenuViewController
import UIKit.UIDocumentPickerExtensionViewController
import UIKit.UIDocumentPickerViewController
import UIKit.UIDragInteraction
import UIKit.UIDragItem
import UIKit.UIDragPreview
import UIKit.UIDragPreviewParameters
import UIKit.UIDragSession
import UIKit.UIDropInteraction
import UIKit.UIDynamicAnimator
import UIKit.UIDynamicBehavior
import UIKit.UIDynamicItemBehavior
import UIKit.UIEvent
import UIKit.UIEventAttribution
import UIKit.UIEventAttributionView
import UIKit.UIFeedbackGenerator
import UIKit.UIFieldBehavior
import UIKit.UIFocus
import UIKit.UIFocusAnimationCoordinator
import UIKit.UIFocusDebugger
import UIKit.UIFocusGuide
import UIKit.UIFocusMovementHint
import UIKit.UIFocusSystem
import UIKit.UIFont
import UIKit.UIFontDescriptor
import UIKit.UIFontMetrics
import UIKit.UIFontPickerViewController
import UIKit.UIFontPickerViewControllerConfiguration
import UIKit.UIGeometry
import UIKit.UIGestureRecognizer
import UIKit.UIGestureRecognizerSubclass
import UIKit.UIGraphics
import UIKit.UIGraphicsImageRenderer
import UIKit.UIGraphicsPDFRenderer
import UIKit.UIGraphicsRenderer
import UIKit.UIGraphicsRendererSubclass
import UIKit.UIGravityBehavior
import UIKit.UIGuidedAccess
import UIKit.UIGuidedAccessRestrictions
import UIKit.UIHoverGestureRecognizer
import UIKit.UIImage
import UIKit.UIImageAsset
import UIKit.UIImageConfiguration
import UIKit.UIImagePickerController
import UIKit.UIImageSymbolConfiguration
import UIKit.UIImageView
import UIKit.UIImpactFeedbackGenerator
import UIKit.UIIndirectScribbleInteraction
import UIKit.UIInputView
import UIKit.UIInputViewController
import UIKit.UIInteraction
import UIKit.UIInterface
import UIKit.UIKey
import UIKit.UIKeyCommand
import UIKit.UIKeyConstants
@_exported import UIKit.UIKitCore
import UIKit.UIKitDefines
import UIKit.UILabel
import UIKit.UILargeContentViewer
import UIKit.UILayoutGuide
import UIKit.UILexicon
import UIKit.UIListContentConfiguration
import UIKit.UIListContentImageProperties
import UIKit.UIListContentTextProperties
import UIKit.UIListSeparatorConfiguration
import UIKit.UILocalNotification
import UIKit.UILocalizedIndexedCollation
import UIKit.UILongPressGestureRecognizer
import UIKit.UIManagedDocument
import UIKit.UIMenu
import UIKit.UIMenuBuilder
import UIKit.UIMenuController
import UIKit.UIMenuElement
import UIKit.UIMenuSystem
import UIKit.UIMotionEffect
import UIKit.UINavigationBar
import UIKit.UINavigationBarAppearance
import UIKit.UINavigationController
import UIKit.UINavigationItem
import UIKit.UINib
import UIKit.UINibDeclarations
import UIKit.UINibLoading
import UIKit.UINotificationFeedbackGenerator
import UIKit.UIOpenURLContext
import UIKit.UIPageControl
import UIKit.UIPageViewController
import UIKit.UIPanGestureRecognizer
import UIKit.UIPasteConfiguration
import UIKit.UIPasteConfigurationSupporting
import UIKit.UIPasteboard
import UIKit.UIPencilInteraction
import UIKit.UIPickerView
import UIKit.UIPinchGestureRecognizer
import UIKit.UIPointerInteraction
import UIKit.UIPointerLockState
import UIKit.UIPointerRegion
import UIKit.UIPointerStyle
import UIKit.UIPopoverBackgroundView
import UIKit.UIPopoverController
import UIKit.UIPopoverPresentationController
import UIKit.UIPopoverSupport
import UIKit.UIPresentationController
import UIKit.UIPress
import UIKit.UIPressesEvent
import UIKit.UIPreviewInteraction
import UIKit.UIPreviewParameters
import UIKit.UIPrintError
import UIKit.UIPrintFormatter
import UIKit.UIPrintInfo
import UIKit.UIPrintInteractionController
import UIKit.UIPrintPageRenderer
import UIKit.UIPrintPaper
import UIKit.UIPrintServiceExtension
import UIKit.UIPrinter
import UIKit.UIPrinterPickerController
import UIKit.UIProgressView
import UIKit.UIPushBehavior
import UIKit.UIReferenceLibraryViewController
import UIKit.UIRefreshControl
import UIKit.UIRegion
import UIKit.UIResponder
import UIKit.UIResponder_UIActivityItemsConfiguration
import UIKit.UIRotationGestureRecognizer
import UIKit.UIScene
import UIKit.UISceneActivationConditions
import UIKit.UISceneDefinitions
import UIKit.UISceneOptions
import UIKit.UISceneSession
import UIKit.UIScreen
import UIKit.UIScreenEdgePanGestureRecognizer
import UIKit.UIScreenMode
import UIKit.UIScreenshotService
import UIKit.UIScribbleInteraction
import UIKit.UIScrollView
import UIKit.UISearchBar
import UIKit.UISearchContainerViewController
import UIKit.UISearchController
import UIKit.UISearchDisplayController
import UIKit.UISearchSuggestion
import UIKit.UISearchTextField
import UIKit.UISegmentedControl
import UIKit.UISelectionFeedbackGenerator
import UIKit.UISlider
import UIKit.UISnapBehavior
import UIKit.UISplitViewController
import UIKit.UISpringLoadedInteraction
import UIKit.UISpringLoadedInteractionSupporting
import UIKit.UIStackView
import UIKit.UIStateRestoration
import UIKit.UIStatusBarManager
import UIKit.UIStepper
import UIKit.UIStoryboard
import UIKit.UIStoryboardPopoverSegue
import UIKit.UIStoryboardSegue
import UIKit.UIStringDrawing
import UIKit.UISwipeActionsConfiguration
import UIKit.UISwipeGestureRecognizer
import UIKit.UISwitch
import UIKit.UITabBar
import UIKit.UITabBarAppearance
import UIKit.UITabBarController
import UIKit.UITabBarItem
import UIKit.UITableView
import UIKit.UITableViewCell
import UIKit.UITableViewController
import UIKit.UITableViewHeaderFooterView
import UIKit.UITapGestureRecognizer
import UIKit.UITargetedDragPreview
import UIKit.UITargetedPreview
import UIKit.UITextChecker
import UIKit.UITextDragPreviewRenderer
import UIKit.UITextDragURLPreviews
import UIKit.UITextDragging
import UIKit.UITextDropProposal
import UIKit.UITextDropping
import UIKit.UITextField
import UIKit.UITextFormattingCoordinator
import UIKit.UITextInput
import UIKit.UITextInputTraits
import UIKit.UITextInteraction
import UIKit.UITextItemInteraction
import UIKit.UITextPasteConfigurationSupporting
import UIKit.UITextPasteDelegate
import UIKit.UITextView
import UIKit.UITimingCurveProvider
import UIKit.UITimingParameters
import UIKit.UIToolbar
import UIKit.UIToolbarAppearance
import UIKit.UITouch
import UIKit.UITraitCollection
import UIKit.UIUserActivity
import UIKit.UIUserNotificationSettings
import UIKit.UIVibrancyEffect
import UIKit.UIVideoEditorController
import UIKit.UIView
import UIKit.UIViewAnimating
import UIKit.UIViewConfigurationState
import UIKit.UIViewController
import UIKit.UIViewControllerTransitionCoordinator
import UIKit.UIViewControllerTransitioning
import UIKit.UIViewPropertyAnimator
import UIKit.UIVisualEffect
import UIKit.UIVisualEffectView
import UIKit.UIWebView
import UIKit.UIWindow
import UIKit.UIWindowScene
import UIKit.UNNotificationResponse_UIKitAdditions

@available(iOS 14.0, tvOS 14.0, *)
struct NSDiffableDataSourceSectionSnapshot<ItemIdentifierType> where ItemIdentifierType : Hashable {
  init()
  init(_ snapshot: NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>)
  mutating func append(_ items: [ItemIdentifierType], to parent: ItemIdentifierType? = nil)
  mutating func insert(_ items: [ItemIdentifierType], before item: ItemIdentifierType)
  mutating func insert(_ items: [ItemIdentifierType], after item: ItemIdentifierType)
  mutating func delete(_ items: [ItemIdentifierType])
  mutating func deleteAll()
  mutating func expand(_ items: [ItemIdentifierType])
  mutating func collapse(_ items: [ItemIdentifierType])
  mutating func replace(childrenOf parent: ItemIdentifierType, using snapshot: NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>)
  mutating func insert(_ snapshot: NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>, before item: (ItemIdentifierType))
  mutating func insert(_ snapshot: NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>, after item: (ItemIdentifierType))
  func isExpanded(_ item: ItemIdentifierType) -> Bool
  func isVisible(_ item: ItemIdentifierType) -> Bool
  func contains(_ item: ItemIdentifierType) -> Bool
  func level(of item: ItemIdentifierType) -> Int
  func index(of item: ItemIdentifierType) -> Int?
  func parent(of child: ItemIdentifierType) -> ItemIdentifierType?
  func snapshot(of parent: ItemIdentifierType, includingParent: Bool = false) -> NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>
  var items: [ItemIdentifierType] { get }
  var rootItems: [ItemIdentifierType] { get }
  var visibleItems: [ItemIdentifierType] { get }
  func visualDescription() -> String
}

@available(iOS 14.0, tvOS 14.0, *)
extension NSDiffableDataSourceSectionSnapshot : _ObjectiveCBridgeable {
  func _bridgeToObjectiveC() -> NSDiffableDataSourceSectionSnapshotReference
  static func _forceBridgeFromObjectiveC(_ input: NSDiffableDataSourceSectionSnapshotReference, result: inout NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>?)
  static func _conditionallyBridgeFromObjectiveC(_ input: NSDiffableDataSourceSectionSnapshotReference, result: inout NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ snapshot: NSDiffableDataSourceSectionSnapshotReference?) -> NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>
  typealias _ObjectiveCType = NSDiffableDataSourceSectionSnapshotReference
}

@available(iOS 14.0, tvOS 14.0, *)
struct NSDiffableDataSourceSectionTransaction<SectionIdentifierType, ItemIdentifierType> where SectionIdentifierType : Hashable, ItemIdentifierType : Hashable {
  var sectionIdentifier: SectionIdentifierType { get }
  var initialSnapshot: NSDiffableDataSourceSectionSnapshot<ItemIdentifierType> { get }
  var finalSnapshot: NSDiffableDataSourceSectionSnapshot<ItemIdentifierType> { get }
  var difference: CollectionDifference<ItemIdentifierType> { get }
}

@available(iOS 13.0, tvOS 13.0, *)
struct NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType> where SectionIdentifierType : Hashable, ItemIdentifierType : Hashable {
  init()
  var numberOfItems: Int { get }
  var numberOfSections: Int { get }
  var sectionIdentifiers: [SectionIdentifierType] { get }
  var itemIdentifiers: [ItemIdentifierType] { get }
  func numberOfItems(inSection identifier: SectionIdentifierType) -> Int
  func itemIdentifiers(inSection identifier: SectionIdentifierType) -> [ItemIdentifierType]
  func sectionIdentifier(containingItem identifier: ItemIdentifierType) -> SectionIdentifierType?
  func indexOfItem(_ identifier: ItemIdentifierType) -> Int?
  func indexOfSection(_ identifier: SectionIdentifierType) -> Int?
  mutating func appendItems(_ identifiers: [ItemIdentifierType], toSection sectionIdentifier: SectionIdentifierType? = nil)
  mutating func insertItems(_ identifiers: [ItemIdentifierType], beforeItem beforeIdentifier: ItemIdentifierType)
  mutating func insertItems(_ identifiers: [ItemIdentifierType], afterItem afterIdentifier: ItemIdentifierType)
  mutating func deleteItems(_ identifiers: [ItemIdentifierType])
  mutating func deleteAllItems()
  mutating func moveItem(_ identifier: ItemIdentifierType, beforeItem toIdentifier: ItemIdentifierType)
  mutating func moveItem(_ identifier: ItemIdentifierType, afterItem toIdentifier: ItemIdentifierType)
  mutating func reloadItems(_ identifiers: [ItemIdentifierType])
  mutating func appendSections(_ identifiers: [SectionIdentifierType])
  mutating func insertSections(_ identifiers: [SectionIdentifierType], beforeSection toIdentifier: SectionIdentifierType)
  mutating func insertSections(_ identifiers: [SectionIdentifierType], afterSection toIdentifier: SectionIdentifierType)
  mutating func deleteSections(_ identifiers: [SectionIdentifierType])
  mutating func moveSection(_ identifier: SectionIdentifierType, beforeSection toIdentifier: SectionIdentifierType)
  mutating func moveSection(_ identifier: SectionIdentifierType, afterSection toIdentifier: SectionIdentifierType)
  mutating func reloadSections(_ identifiers: [SectionIdentifierType])
}

@available(iOS 13.0, tvOS 13.0, *)
extension NSDiffableDataSourceSnapshot : _ObjectiveCBridgeable {
  func _bridgeToObjectiveC() -> NSDiffableDataSourceSnapshotReference
  static func _forceBridgeFromObjectiveC(_ input: NSDiffableDataSourceSnapshotReference, result: inout NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>?)
  static func _conditionallyBridgeFromObjectiveC(_ input: NSDiffableDataSourceSnapshotReference, result: inout NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ snapshot: NSDiffableDataSourceSnapshotReference?) -> NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>
  typealias _ObjectiveCType = NSDiffableDataSourceSnapshotReference
}

@available(iOS 14.0, tvOS 14.0, *)
struct NSDiffableDataSourceTransaction<SectionIdentifierType, ItemIdentifierType> where SectionIdentifierType : Hashable, ItemIdentifierType : Hashable {
  var initialSnapshot: NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType> { get }
  var finalSnapshot: NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType> { get }
  var difference: CollectionDifference<ItemIdentifierType> { get }
  var sectionTransactions: [NSDiffableDataSourceSectionTransaction<SectionIdentifierType, ItemIdentifierType>] { get }
}

@available(swift, deprecated: 4.2, message: "Use the overload of UIApplicationMain where the type of the second parameter is UnsafeMutablePointer<UnsafeMutablePointer<Int8>?>, which is the same as the type of CommandLine.unsafeArgv.")
func UIApplicationMain(_ argc: Int32, _ argv: UnsafeMutablePointer<UnsafeMutablePointer<Int8>>!, _ principalClassName: String?, _ delegateClassName: String?) -> Int32

@available(iOS 14.0, tvOS 14.0, *)
struct UIBackgroundConfiguration : Hashable {
  /// Returns a clear configuration, with no default styling.
  static func clear() -> UIBackgroundConfiguration
  /// Returns the default configuration for a plain list cell.
  static func listPlainCell() -> UIBackgroundConfiguration
  /// Returns the default configuration for a plain list header or footer.
  static func listPlainHeaderFooter() -> UIBackgroundConfiguration
  /// Returns the default configuration for a grouped list cell.
  static func listGroupedCell() -> UIBackgroundConfiguration
  /// Returns the default configuration for a grouped list header or footer.
  static func listGroupedHeaderFooter() -> UIBackgroundConfiguration
  /// Returns the default configuration for a sidebar list header.
  static func listSidebarHeader() -> UIBackgroundConfiguration
  /// Returns the default configuration for a sidebar list cell.
  static func listSidebarCell() -> UIBackgroundConfiguration
  /// Returns the default configuration for an accompanied sidebar list cell.
  static func listAccompaniedSidebarCell() -> UIBackgroundConfiguration
  /// Returns the configuration updated for the specified state, by applying the configuration's default values for that state to any properties that have not been customized.
  func updated(for state: UIConfigurationState) -> UIBackgroundConfiguration
  /// A custom view for the background. The custom view must have translatesAutoresizingMaskIntoConstraints
  /// enabled, but may use auto layout constraints internally for layout of subviews.
  var customView: UIView?
  /// The preferred corner radius (using a continuous corner curve) for the background and stroke. Does not apply to any custom view. Default is 0.
  /// If the view is too small to fit the requested radius, the corner curve and radius will be adjusted to fit.
  var cornerRadius: CGFloat
  /// Insets (or outsets, if negative) for the background and stroke, relative to the edges of the containing view. These also apply to the custom view. Default is NSDirectionalEdgeInsetsZero.
  var backgroundInsets: NSDirectionalEdgeInsets
  /// The edges on which the containing view's layout margins are added to the `backgroundInsets`, effectively making the `backgroundInsets` values relative
  /// to the containing view's layout margins for these edges. Default is NSDirectionalRectEdgeNone.
  var edgesAddingLayoutMarginsToBackgroundInsets: NSDirectionalRectEdge
  /// Configures the color of the background. A nil value uses the view's tint color; use `.clear` for no color (transparent).
  var backgroundColor: UIColor?
  /// Optional color transformer that is used to resolve the background color. A nil value means the `backgroundColor` is used as-is.
  var backgroundColorTransformer: UIConfigurationColorTransformer?
  /// Returns the resolved background color for the specified tint color, based on the `backgroundColor` and `backgroundColorTransformer`.
  func resolvedBackgroundColor(for tintColor: UIColor) -> UIColor
  /// The visual effect to apply to the background. Default is nil.
  var visualEffect: UIVisualEffect?
  /// Configures the color of the stroke. A nil value uses the view's tint color; use `.clear` for no color (transparent).
  var strokeColor: UIColor?
  /// Optional color transformer that is used to resolve the stroke color. A nil value means the `strokeColor` is used as-is.
  var strokeColorTransformer: UIConfigurationColorTransformer?
  /// Returns the resolved stroke color for the specified tint color, based on the `strokeColor` and `strokeColorTransformer`.
  func resolvedStrokeColor(for tintColor: UIColor) -> UIColor
  /// The width of the stroke. Default is 0.
  var strokeWidth: CGFloat
  /// Outset (or inset, if negative) for the stroke, relative to the background (including any backgroundInsets). Default is 0.
  /// The corner radius of the stroke is adjusted for any outset to remain concentric with the background.
  var strokeOutset: CGFloat
  func hash(into hasher: inout Hasher)
  static func == (a: UIBackgroundConfiguration, b: UIBackgroundConfiguration) -> Bool
  var hashValue: Int { get }
}

@available(iOS 14.0, tvOS 14.0, *)
extension UIBackgroundConfiguration : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  var description: String { get }
  var debugDescription: String { get }
  var customMirror: Mirror { get }
}

@available(iOS 14.0, tvOS 14.0, *)
struct UICellAccessory {
  typealias ActionHandler = () -> Void
  /// The states an accessory is displayed for.
  enum DisplayedState {
    /// The accessory is always displayed.
    case always
    /// The accessory is displayed only when the cell is editing.
    case whenEditing
    /// The accessory is displayed only when the cell is not editing.
    case whenNotEditing
    static func == (a: UICellAccessory.DisplayedState, b: UICellAccessory.DisplayedState) -> Bool
    func hash(into hasher: inout Hasher)
    var hashValue: Int { get }
  }
  /// The layout dimension used for an accessory.
  enum LayoutDimension {
    /// The actual dimension of the accessory is used.
    case actual
    /// The system standard layout dimension for accessories is used.
    case standard
    /// The specified custom value is used for the dimension.
    case custom(CGFloat)
  }
  struct DisclosureIndicatorOptions {
    /// Hidden accessories take up space in the layout, but are not visible and do not provide any behaviors.
    /// Use this property to achieve a consistent layout across cells when some show the accessory and others do not.
    var isHidden: Bool
    /// The layout width that is reserved for the accessory, inside which the accessory will be centered.
    var reservedLayoutWidth: UICellAccessory.LayoutDimension
    /// The tint color to apply to the accessory. Default value is nil, which uses the system default.
    var tintColor: UIColor?
    init(isHidden: Bool? = nil, reservedLayoutWidth: UICellAccessory.LayoutDimension? = nil, tintColor: UIColor? = nil)
  }
  /// A disclosure chevron that points in the trailing direction. Placed on the trailing edge.
  static func disclosureIndicator(displayed: UICellAccessory.DisplayedState = .always, options: UICellAccessory.DisclosureIndicatorOptions = DisclosureIndicatorOptions()) -> UICellAccessory
  struct CheckmarkOptions {
    /// Hidden accessories take up space in the layout, but are not visible and do not provide any behaviors.
    /// Use this property to achieve a consistent layout across cells when some show the accessory and others do not.
    var isHidden: Bool
    /// The layout width that is reserved for the accessory, inside which the accessory will be centered.
    var reservedLayoutWidth: UICellAccessory.LayoutDimension
    /// The tint color to apply to the accessory. Default value is nil, which uses the system default.
    var tintColor: UIColor?
    init(isHidden: Bool? = nil, reservedLayoutWidth: UICellAccessory.LayoutDimension? = nil, tintColor: UIColor? = nil)
  }
  /// A checkmark with default green color. Placed on the trailing edge.
  static func checkmark(displayed: UICellAccessory.DisplayedState = .always, options: UICellAccessory.CheckmarkOptions = CheckmarkOptions()) -> UICellAccessory
  struct DeleteOptions {
    /// Hidden accessories take up space in the layout, but are not visible and do not provide any behaviors.
    /// Use this property to achieve a consistent layout across cells when some show the accessory and others do not.
    var isHidden: Bool
    /// The layout width that is reserved for the accessory, inside which the accessory will be centered.
    var reservedLayoutWidth: UICellAccessory.LayoutDimension
    /// The tint color to apply to the accessory. Default value is nil, which uses the system default.
    var tintColor: UIColor?
    /// The background color to apply to the accessory. Default value is nil, which uses the system default.
    var backgroundColor: UIColor?
    init(isHidden: Bool? = nil, reservedLayoutWidth: UICellAccessory.LayoutDimension? = nil, tintColor: UIColor? = nil, backgroundColor: UIColor? = nil)
  }
  /// A delete control (minus sign inside a circle) with default red color. Placed on the leading edge.
  static func delete(displayed: UICellAccessory.DisplayedState = .whenEditing, options: UICellAccessory.DeleteOptions = DeleteOptions(), actionHandler: UICellAccessory.ActionHandler? = nil) -> UICellAccessory
  struct InsertOptions {
    /// Hidden accessories take up space in the layout, but are not visible and do not provide any behaviors.
    /// Use this property to achieve a consistent layout across cells when some show the accessory and others do not.
    var isHidden: Bool
    /// The layout width that is reserved for the accessory, inside which the accessory will be centered.
    var reservedLayoutWidth: UICellAccessory.LayoutDimension
    /// The tint color to apply to the accessory. Default value is nil, which uses the system default.
    var tintColor: UIColor?
    /// The background color to apply to the accessory. Default value is nil, which uses the system default.
    var backgroundColor: UIColor?
    init(isHidden: Bool? = nil, reservedLayoutWidth: UICellAccessory.LayoutDimension? = nil, tintColor: UIColor? = nil, backgroundColor: UIColor? = nil)
  }
  /// An insert control (plus sign inside a circle) with default green color. Placed on the leading edge.
  static func insert(displayed: UICellAccessory.DisplayedState = .whenEditing, options: UICellAccessory.InsertOptions = InsertOptions(), actionHandler: UICellAccessory.ActionHandler? = nil) -> UICellAccessory
  struct ReorderOptions {
    /// Hidden accessories take up space in the layout, but are not visible and do not provide any behaviors.
    /// Use this property to achieve a consistent layout across cells when some show the accessory and others do not.
    var isHidden: Bool
    /// The layout width that is reserved for the accessory, inside which the accessory will be centered.
    var reservedLayoutWidth: UICellAccessory.LayoutDimension
    /// The tint color to apply to the accessory. Default value is nil, which uses the system default.
    var tintColor: UIColor?
    /// Whether a vertical separator is displayed before the accessory when it is placed after another
    /// accessory. Default is true.
    var showsVerticalSeparator: Bool
    init(isHidden: Bool? = nil, reservedLayoutWidth: UICellAccessory.LayoutDimension? = nil, tintColor: UIColor? = nil, showsVerticalSeparator: Bool? = nil)
  }
  /// A reorder control (three horizontal lines) with default gray color that automatically initiates interactive
  /// reordering on the collection view when dragged (if supported). Placed on the trailing edge.
  static func reorder(displayed: UICellAccessory.DisplayedState = .whenEditing, options: UICellAccessory.ReorderOptions = ReorderOptions()) -> UICellAccessory
  struct MultiselectOptions {
    /// Hidden accessories take up space in the layout, but are not visible and do not provide any behaviors.
    /// Use this property to achieve a consistent layout across cells when some show the accessory and others do not.
    var isHidden: Bool
    /// The layout width that is reserved for the accessory, inside which the accessory will be centered.
    var reservedLayoutWidth: UICellAccessory.LayoutDimension
    /// The tint color to apply to the accessory. Default value is nil, which uses the system default.
    var tintColor: UIColor?
    /// The background color to apply to the accessory. Default value is nil, which uses the system default.
    var backgroundColor: UIColor?
    init(isHidden: Bool? = nil, reservedLayoutWidth: UICellAccessory.LayoutDimension? = nil, tintColor: UIColor? = nil, backgroundColor: UIColor? = nil)
  }
  /// A two-state control whose appearance follows the selection state of the cell (empty circle when deselected,
  /// filled circle with checkmark when selected). Placed on the leading edge.
  static func multiselect(displayed: UICellAccessory.DisplayedState = .whenEditing, options: UICellAccessory.MultiselectOptions = MultiselectOptions()) -> UICellAccessory
  struct OutlineDisclosureOptions {
    enum Style {
      /// The style will be automatically determined based on whether the cell is configured
      /// to be a section header or not.
      case automatic
      /// A style appropriate for a section header, where a tap anywhere in the header will
      /// toggle the expansion state of the item (the cell cannot be selected).
      case header
      /// A style appropriate for a cell which can be selected itself and also has nested children,
      /// where only taps on the outline disclosure will toggle the expansion state of the item;
      /// taps on the cell will select the item as normal.
      case cell
      static func == (a: UICellAccessory.OutlineDisclosureOptions.Style, b: UICellAccessory.OutlineDisclosureOptions.Style) -> Bool
      func hash(into hasher: inout Hasher)
      var hashValue: Int { get }
    }
    /// The style of the outline disclosure accessory. Default is automatic.
    var style: UICellAccessory.OutlineDisclosureOptions.Style
    /// Hidden accessories take up space in the layout, but are not visible and do not provide any behaviors.
    /// Use this property to achieve a consistent layout across cells when some show the accessory and others do not.
    var isHidden: Bool
    /// The layout width that is reserved for the accessory, inside which the accessory will be centered.
    var reservedLayoutWidth: UICellAccessory.LayoutDimension
    /// The tint color to apply to the accessory. Default value is nil, which uses the system default.
    var tintColor: UIColor?
    init(style: UICellAccessory.OutlineDisclosureOptions.Style? = nil, isHidden: Bool? = nil, reservedLayoutWidth: UICellAccessory.LayoutDimension? = nil, tintColor: UIColor? = nil)
  }
  /// A rotating disclosure chevron for use with outlines, used to indicate and toggle the expanded/collapsed
  /// state of the item. Placed on the trailing edge on iOS and iPadOS. On Catalyst, placed on the trailing
  /// edge of headers, but the leading edge of cells.
  static func outlineDisclosure(displayed: UICellAccessory.DisplayedState = .always, options: UICellAccessory.OutlineDisclosureOptions = OutlineDisclosureOptions(), actionHandler: UICellAccessory.ActionHandler? = nil) -> UICellAccessory
  struct LabelOptions {
    /// Hidden accessories take up space in the layout, but are not visible and do not provide any behaviors.
    /// Use this property to achieve a consistent layout across cells when some show the accessory and others do not.
    var isHidden: Bool
    /// The layout width that is reserved for the accessory, inside which the accessory will be centered.
    var reservedLayoutWidth: UICellAccessory.LayoutDimension
    /// The tint color to apply to the accessory. Default value is nil, which uses the system default.
    var tintColor: UIColor?
    /// The font used for the label. Default is the preferred font for UIFontTextStyleBody.
    var font: UIFont
    /// Whether the label automatically adjusts its font based on the content size category. Default is true.
    var adjustsFontForContentSizeCategory: Bool
    init(isHidden: Bool? = nil, reservedLayoutWidth: UICellAccessory.LayoutDimension? = nil, tintColor: UIColor? = nil, font: UIFont? = nil, adjustsFontForContentSizeCategory: Bool? = nil)
  }
  /// A label displaying a short string of text, typically a small number such as a count for the associated
  /// item. Placed on the trailing edge.
  static func label(text: String, displayed: UICellAccessory.DisplayedState = .always, options: UICellAccessory.LabelOptions = LabelOptions()) -> UICellAccessory
  /// Specifies the edge, displayed states, and position for an accessory.
  enum Placement {
    /// Return an index to insert the accessory at, given an array of the existing accessories
    /// on the edge (in leading to trailing order).
    typealias Position = ([UICellAccessory]) -> Int
    /// Positions the accessory before the accessory matching the type specified, or at the beginning if not found.
    static func position(before accessory: UICellAccessory) -> UICellAccessory.Placement.Position
    /// Positions the accessory after the accessory matching the type specified, or at the end if not found.
    static func position(after accessory: UICellAccessory) -> UICellAccessory.Placement.Position
    /// Accessory placed on the leading edge, by default displayed for both states, and inserted at a
    /// position closest to the cell content.
    case leading(displayed: UICellAccessory.DisplayedState = .always, at: UICellAccessory.Placement.Position = { $0.count })
    /// Accessory placed on the trailing edge, by default displayed for both states, and inserted at a
    /// position closest to the cell content.
    case trailing(displayed: UICellAccessory.DisplayedState = .always, at: UICellAccessory.Placement.Position = { _ in 0 })
  }
  struct CustomViewConfiguration {
    /// The custom view to display.
    let customView: UIView
    /// The placement for the accessory.
    let placement: UICellAccessory.Placement
    /// Hidden accessories take up space in the layout, but are not visible and do not provide any behaviors.
    /// Use this property to achieve a consistent layout across cells when some show the accessory and others do not.
    var isHidden: Bool
    /// The layout width that is reserved for the accessory, inside which the accessory will be centered.
    var reservedLayoutWidth: UICellAccessory.LayoutDimension
    /// The tint color to apply to the accessory. Default value is nil, which uses the system default.
    var tintColor: UIColor?
    /// Whether the current frame size of the view is preserved (true), or whether it is sized during
    /// layout of accessories (false). Default is false.
    var maintainsFixedSize: Bool
    init(customView: UIView, placement: UICellAccessory.Placement, isHidden: Bool? = nil, reservedLayoutWidth: UICellAccessory.LayoutDimension? = nil, tintColor: UIColor? = nil, maintainsFixedSize: Bool? = nil)
  }
  /// An accessory using a custom view.
  static func customView(configuration: UICellAccessory.CustomViewConfiguration) -> UICellAccessory
  enum AccessoryType : Hashable {
    case disclosureIndicator
    case outlineDisclosure
    case checkmark
    case delete
    case insert
    case reorder
    case multiselect
    case label
    case customView(UIView)
    static func == (lhs: UICellAccessory.AccessoryType, rhs: UICellAccessory.AccessoryType) -> Bool
    func hash(into hasher: inout Hasher)
    var hashValue: Int { get }
  }
  let accessoryType: UICellAccessory.AccessoryType
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICellAccessory.DisplayedState : Equatable {
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICellAccessory.DisplayedState : Hashable {
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICellAccessory.OutlineDisclosureOptions.Style : Equatable {
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICellAccessory.OutlineDisclosureOptions.Style : Hashable {
}

@available(iOS 14.0, tvOS 14.0, *)
struct UICellConfigurationState : UIConfigurationState, Hashable {
  @available(iOS 14.0, *)
  enum DragState : Hashable {
    /// The cell is not associated with a drag session.
    case none
    /// The cell is being lifted, before has joined a drag session.
    case lifting
    /// The cell is part of an active drag session.
    case dragging
    static func == (a: UICellConfigurationState.DragState, b: UICellConfigurationState.DragState) -> Bool
    func hash(into hasher: inout Hasher)
    var hashValue: Int { get }
  }
  @available(iOS 14.0, *)
  enum DropState : Hashable {
    /// The cell is not associated with a drag session.
    case none
    /// A drag session is active and may perform a drop in the cell's container, but the cell itself
    /// is not the drop target.
    case notTargeted
    /// The cell is the drop target for a drag session.
    case targeted
    static func == (a: UICellConfigurationState.DropState, b: UICellConfigurationState.DropState) -> Bool
    func hash(into hasher: inout Hasher)
    var hashValue: Int { get }
  }
  var traitCollection: UITraitCollection
  var isDisabled: Bool
  var isHighlighted: Bool
  var isSelected: Bool
  var isFocused: Bool
  var isEditing: Bool
  var isExpanded: Bool
  var isSwiped: Bool
  var isReordering: Bool
  var cellDragState: UICellConfigurationState.DragState
  var cellDropState: UICellConfigurationState.DropState
  subscript(key: UIConfigurationStateCustomKey) -> AnyHashable?
  init(traitCollection: UITraitCollection)
  static func == (lhs: UICellConfigurationState, rhs: UICellConfigurationState) -> Bool
  func hash(into hasher: inout Hasher)
  var hashValue: Int { get }
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICellConfigurationState : _ObjectiveCBridgeable {
  func _bridgeToObjectiveC() -> __UICellConfigurationState
  static func _forceBridgeFromObjectiveC(_ input: __UICellConfigurationState, result: inout UICellConfigurationState?)
  static func _conditionallyBridgeFromObjectiveC(_ input: __UICellConfigurationState, result: inout UICellConfigurationState?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ _state: __UICellConfigurationState?) -> UICellConfigurationState
  typealias _ObjectiveCType = __UICellConfigurationState
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICellConfigurationState : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  var description: String { get }
  var debugDescription: String { get }
  var customMirror: Mirror { get }
}

@available(iOS 14.0, tvOS 14.0, *)
struct UICollectionLayoutListConfiguration {
  enum Appearance {
    case plain
    case grouped
    @available(tvOS, unavailable)
    case insetGrouped
    @available(tvOS, unavailable)
    case sidebar
    @available(tvOS, unavailable)
    case sidebarPlain
    static func == (a: UICollectionLayoutListConfiguration.Appearance, b: UICollectionLayoutListConfiguration.Appearance) -> Bool
    func hash(into hasher: inout Hasher)
    var hashValue: Int { get }
  }
  enum HeaderMode {
    case none
    case supplementary
    case firstItemInSection
    static func == (a: UICollectionLayoutListConfiguration.HeaderMode, b: UICollectionLayoutListConfiguration.HeaderMode) -> Bool
    func hash(into hasher: inout Hasher)
    var hashValue: Int { get }
  }
  enum FooterMode {
    case none
    case supplementary
    static func == (a: UICollectionLayoutListConfiguration.FooterMode, b: UICollectionLayoutListConfiguration.FooterMode) -> Bool
    func hash(into hasher: inout Hasher)
    var hashValue: Int { get }
  }
  @available(tvOS, unavailable)
  typealias SwipeActionsConfigurationProvider = (IndexPath) -> UISwipeActionsConfiguration?
  /// A closure that is executed by list sections to provide granular control over separator appearance.
  /// 
  /// - Parameter itemIndexPath: The `IndexPath` of the item for which separators are being configured.
  /// - Parameter sectionSeparatorConfiguration: The list section's separator configuration for this cell. This configuration contains
  /// the values for separator visibility and insets according to the current state of the item.
  ///
  /// - Returns: The configuration to use for separators at `itemIndexPath`.
  @available(iOS 14.5, *)
  @available(tvOS, unavailable)
  typealias ItemSeparatorHandler = (IndexPath, UIListSeparatorConfiguration) -> UIListSeparatorConfiguration
  init(appearance: UICollectionLayoutListConfiguration.Appearance)
  var appearance: UICollectionLayoutListConfiguration.Appearance { get }
  /// Whether this section shows separators or not. For additional control, see separatorConfiguration
  /// Note that when this property is NO, the separatorConfiguration is ineffective.
  @available(tvOS, unavailable)
  var showsSeparators: Bool
  /// The section's preferred configuration for separators. This configuration only takes effect if showsSeparators is YES.
  /// For more more granular control over separator appearance, use `itemSeparatorHandler`.
  @available(iOS 14.5, *)
  @available(tvOS, unavailable)
  var separatorConfiguration: UIListSeparatorConfiguration
  /// The configuration returned from this block will be treated as the final separator configuration
  /// for the item at the passed in `IndexPath`.
  @available(iOS 14.5, *)
  @available(tvOS, unavailable)
  var itemSeparatorHandler: UICollectionLayoutListConfiguration.ItemSeparatorHandler?
  var backgroundColor: UIColor?
  @available(tvOS, unavailable)
  var leadingSwipeActionsConfigurationProvider: UICollectionLayoutListConfiguration.SwipeActionsConfigurationProvider?
  @available(tvOS, unavailable)
  var trailingSwipeActionsConfigurationProvider: UICollectionLayoutListConfiguration.SwipeActionsConfigurationProvider?
  var headerMode: UICollectionLayoutListConfiguration.HeaderMode
  var footerMode: UICollectionLayoutListConfiguration.FooterMode
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionLayoutListConfiguration.Appearance : Equatable {
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionLayoutListConfiguration.Appearance : Hashable {
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionLayoutListConfiguration.HeaderMode : Equatable {
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionLayoutListConfiguration.HeaderMode : Hashable {
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionLayoutListConfiguration.FooterMode : Equatable {
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionLayoutListConfiguration.FooterMode : Hashable {
}

@available(iOS 13.0, tvOS 13.0, *)
class UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType> : NSObject, UICollectionViewDataSource where SectionIdentifierType : Hashable, ItemIdentifierType : Hashable {
  typealias CellProvider = (UICollectionView, IndexPath, ItemIdentifierType) -> UICollectionViewCell?
  typealias SupplementaryViewProvider = (UICollectionView, String, IndexPath) -> UICollectionReusableView?
  var supplementaryViewProvider: UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.SupplementaryViewProvider?
  init(collectionView: UICollectionView, cellProvider: @escaping UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.CellProvider)
  func apply(_ snapshot: NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>, animatingDifferences: Bool = true, completion: (() -> Void)? = nil)
  func snapshot() -> NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>
  func itemIdentifier(for indexPath: IndexPath) -> ItemIdentifierType?
  func indexPath(for itemIdentifier: ItemIdentifierType) -> IndexPath?
  func numberOfSections(in collectionView: UICollectionView) -> Int
  func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int
  func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell
  func collectionView(_ collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, at indexPath: IndexPath) -> UICollectionReusableView
  func collectionView(_ collectionView: UICollectionView, canMoveItemAt indexPath: IndexPath) -> Bool
  func collectionView(_ collectionView: UICollectionView, moveItemAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath)
  func indexTitles(for collectionView: UICollectionView) -> [String]?
  func collectionView(_ collectionView: UICollectionView, indexPathForIndexTitle title: String, at index: Int) -> IndexPath
  func description() -> String
  override dynamic init()
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewDiffableDataSource {
  func apply(_ snapshot: NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>, to section: SectionIdentifierType, animatingDifferences: Bool = true, completion: (() -> Void)? = nil)
  func snapshot(for section: SectionIdentifierType) -> NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewDiffableDataSource {
  struct ReorderingHandlers {
    var canReorderItem: ((ItemIdentifierType) -> Bool)?
    var willReorder: ((NSDiffableDataSourceTransaction<SectionIdentifierType, ItemIdentifierType>) -> Void)?
    var didReorder: ((NSDiffableDataSourceTransaction<SectionIdentifierType, ItemIdentifierType>) -> Void)?
    init()
  }
  var reorderingHandlers: UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.ReorderingHandlers
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewDiffableDataSource {
  struct SectionSnapshotHandlers<ItemIdentifierType> where ItemIdentifierType : Hashable {
    var shouldExpandItem: ((ItemIdentifierType) -> Bool)?
    var willExpandItem: ((ItemIdentifierType) -> Void)?
    var shouldCollapseItem: ((ItemIdentifierType) -> Bool)?
    var willCollapseItem: ((ItemIdentifierType) -> Void)?
    var snapshotForExpandingParent: ((ItemIdentifierType, NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>) -> NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>)?
    init()
  }
  var sectionSnapshotHandlers: UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.SectionSnapshotHandlers<ItemIdentifierType>
}

@available(iOS 14.0, tvOS 14.0, *)
struct UIConfigurationColorTransformer {
  let transform: (UIColor) -> UIColor
  init(_ transform: @escaping (UIColor) -> UIColor)
  func callAsFunction(_ input: UIColor) -> UIColor
  /// A color transformer that returns a grayscale version of the color.
  static let grayscale: UIConfigurationColorTransformer
  /// A color transformer that either passes the original color through, or replaces it with the system accent color.
  /// - When the system accent color is set to Multicolor: Returns the original color.
  /// - When the system accent color is configured to any other color:  Returns that color.
  /// - On platforms without a system accent color: Returns the original color.
  static let preferredTint: UIConfigurationColorTransformer
  /// A color transformer that gives the color a monochrome tint. Use this to deemphasize the tinted item.
  /// It remains monochrome regardless of the system accent color (if the platform has one).
  static let monochromeTint: UIConfigurationColorTransformer
}

@available(iOS 14.0, tvOS 14.0, *)
protocol UIConfigurationState {
  /// Returns a new instance with the specified trait collection.
  init(traitCollection: UITraitCollection)
  var traitCollection: UITraitCollection { get set }
  /// Access custom states by key.
  subscript(key: UIConfigurationStateCustomKey) -> AnyHashable? { get set }
}

@available(iOS 14.0, tvOS 14.0, *)
protocol UIContentConfiguration {
  /// Initializes and returns a new instance of the content view using this configuration.
  func makeContentView() -> UIView & UIContentView
  /// Returns the configuration updated for the specified state, by applying the configuration's default values for that state to any properties that have not been customized.
  func updated(for state: UIConfigurationState) -> Self
}

@available(iOS 14.0, tvOS 14.0, *)
protocol UIContentView : NSObjectProtocol {
  /// Returns the current configuration of the view. Setting this property applies the new configuration to the view.
  var configuration: UIContentConfiguration { get set }
}

@available(swift, obsoleted: 4.2, renamed: "getter:UIDeviceOrientation.isLandscape(self:)")
func UIDeviceOrientationIsLandscape(_ orientation: UIDeviceOrientation) -> Bool

@available(swift, obsoleted: 4.2, renamed: "getter:UIDeviceOrientation.isPortrait(self:)")
func UIDeviceOrientationIsPortrait(_ orientation: UIDeviceOrientation) -> Bool

@available(swift, obsoleted: 4.2, renamed: "getter:UIDeviceOrientation.isValidInterfaceOrientation(self:)")
func UIDeviceOrientationIsValidInterfaceOrientation(_ orientation: UIDeviceOrientation) -> Bool

@available(swift, deprecated: 4.2, message: "Use == operator instead.")
func UIEdgeInsetsEqualToEdgeInsets(_ insets1: UIEdgeInsets, _ insets2: UIEdgeInsets) -> Bool

@available(swift, deprecated: 4.2, message: "Use == operator instead.")
func UIFloatRangeIsEqualToRange(_ range: UIFloatRange, _ otherRange: UIFloatRange) -> Bool

@available(iOS 14.0, *)
class UIIndirectScribbleInteraction<Delegate> : NSObject, UIInteraction where Delegate : UIIndirectScribbleInteractionDelegate {
  weak var view: @sil_weak UIView? { get }
  weak var delegate: @sil_weak Delegate? { get }
  func willMove(to view: UIView?)
  func didMove(to view: UIView?)
  init(delegate: Delegate)
  var isHandlingWriting: Bool { get }
  override dynamic init()
}

/**
 The protocol to be implemented by the delegate of UIIndirectScribbleInteraction. It will be responsible for supplying a list of writable elements, focusing them, and ultimately providing a real UITextInput that will handle text editing operations.
*/
@available(iOS 14.0, *)
protocol UIIndirectScribbleInteractionDelegate : NSObjectProtocol {
  /**
   Element identifiers are used to identify writable elements in the interaction's view, and will be supplied in every delegate callback. Any type that conforms to Hashable and that can be compared for equality can be used. It is recommended to use simple immutable values, like strings, numbers, or UUIDs.
   */
  associatedtype ElementIdentifier : Hashable = String
  /**
   This method will be called to request the text input elements in a certain rect of the view, each of which represents an area where the user can start writing even if it's not a text input field itself.
   
   - Parameters:
      - interaction: The interaction asking for the elements.
      - rect: The rect around the area where the user is trying to write, in the interaction's view coordinate system. Only elements intersecting this rect should be returned.
      - completion: You must call the completion handler, synchronously or asynchronously, with an array of identifiers of the available elements, or an empty array if no elements are available.
   */
  func indirectScribbleInteraction(_ interaction: UIInteraction, requestElementsIn rect: CGRect, completion: @escaping ([Self.ElementIdentifier]) -> Void)
  /**
       Asks the delegate if an element is currently focused, according to the internal state of the interaction's view.
  
       - Parameters:
          - interaction: The interaction asking for the focused state.
          - elementIdentifier: The identifier of the element the interaction is asking about.
       
       - Returns: YES if the element is the one currently focused.
       */
  func indirectScribbleInteraction(_ interaction: UIInteraction, isElementFocused elementIdentifier: Self.ElementIdentifier) -> Bool
  /**
   Asks the delegate to provide the frame of an element.
   
   - Parameters:
      - interaction: The interaction asking for the element's frame.
      - elementIdentifier: The identifier of the element the interaction is asking about.
   
   - Returns: Frame for the element, in the interactions's view coordinate system.
   */
  func indirectScribbleInteraction(_ interaction: UIInteraction, frameForElement elementIdentifier: Self.ElementIdentifier) -> CGRect
  /**
   Asks the delegate to focus an element to handle text edits. In response, it should make the element the currently focused one, and make the corresponding UITextInput become first responder.
   
   If the element was not focused already, text selection should be set to the character location closest to focusReferencePoint, to avoid any scrolling or shifting of content.
   
   If the element was focused already, no changes in selection should be made and this call can be ignored, but you must still call the completion handler with a reference to the text input.
   
   - Parameters:
      - interaction The interaction that is requesting to focus an element.
      - elementIdentifier The identifier of the element that should be focused.
      @param completion You must always call the completion handler, either synchronously or asynchronously. On success, the first parameter should be the text input that became first responder and that will handle text operations for this element. On failure, call the completion with a nil parameter.
  */
  func indirectScribbleInteraction(_ interaction: UIInteraction, focusElementIfNeeded elementIdentifier: Self.ElementIdentifier, referencePoint focusReferencePoint: CGPoint, completion: @escaping ((UIResponder & UITextInput)?) -> Void)
  /**
   Allow the delegate to delay focusing an element. Normally, Scribble will focus the element as soon as the user begins writing, but if you return YES from this callback, it will wait until the user makes a brief pause. This is useful in cases where the element's frame will shift or transform when becoming focused, which can be disruptive to a user trying to handwrite into it.
   
   Wherever possible it is preferable to adjust the UI behavior to avoid the layout changes, and only use delayed focus as a last resort, since transcription will happen all at once instead of incrementally.
   
   - Parameters:
      - interaction: The interaction asking about delaying focus.
      - elementIdentifier: The identifier of the element the interaction is asking about.
   
   - Returns: YES to delay focusing the element.
   */
  func indirectScribbleInteraction(_ interaction: UIInteraction, shouldDelayFocusForElement elementIdentifier: Self.ElementIdentifier) -> Bool
  /**
   Will be called when the user begins writing into an element. This call will always be paired with a corresponding call to indirectScribbleInteraction:didFinishWritingInElement:. It is recommended to use this call to hide custom placeholders or other UI elements that can interfere with writing.
   
   - Parameters:
      - interaction: The interaction notifying about writing state changes.
      - elementIdentifier: The identifier of the element the user is writing into.
   */
  func indirectScribbleInteraction(_ interaction: UIInteraction, willBeginWritingInElement elementIdentifier: Self.ElementIdentifier)
  /**
   Will be called when the user finished writing into an element, after the last word has been transcribed and committed.
   
   - Parameters:
      - interaction: The interaction notifying about writing state changes.
      - elementIdentifier: The identifier of the element the user finished writing into.
  */
  func indirectScribbleInteraction(_ interaction: UIInteraction, didFinishWritingInElement elementIdentifier: Self.ElementIdentifier)
}

@available(iOS 14.0, *)
extension UIIndirectScribbleInteractionDelegate {
  func indirectScribbleInteraction(_ interaction: UIInteraction, willBeginWritingInElement elementIdentifier: Self.ElementIdentifier)
  func indirectScribbleInteraction(_ interaction: UIInteraction, didFinishWritingInElement elementIdentifier: Self.ElementIdentifier)
  func indirectScribbleInteraction(_ interaction: UIInteraction, shouldDelayFocusForElement elementIdentifier: Self.ElementIdentifier) -> Bool
}

@available(swift, obsoleted: 4.2, renamed: "getter:UIInterfaceOrientation.isLandscape(self:)")
func UIInterfaceOrientationIsLandscape(_ orientation: UIInterfaceOrientation) -> Bool

@available(swift, obsoleted: 4.2, renamed: "getter:UIInterfaceOrientation.isPortrait(self:)")
func UIInterfaceOrientationIsPortrait(_ orientation: UIInterfaceOrientation) -> Bool

@available(iOS 14.0, tvOS 14.0, *)
struct UIListContentConfiguration : UIContentConfiguration, Hashable {
  struct ImageProperties : Hashable {
    /// The symbol configuration to use.
    var preferredSymbolConfiguration: UIImage.SymbolConfiguration?
    /// The tintColor to apply to the image view. Nil will use the image view's
    /// normal inherited tintColor.
    var tintColor: UIColor?
    /// Optional color transformer that is used to resolve the tint color. A nil value means
    /// the `tintColor` is used as-is.
    var tintColorTransformer: UIConfigurationColorTransformer?
    /// Returns the resolved image tint color for the specified tint color of the view, based on
    /// the `tintColor` and `tintColorTransformer`.
    func resolvedTintColor(for tintColor: UIColor) -> UIColor
    /// The preferred corner radius (using a continuous corner curve) for the image.
    /// Default is 0. If the image is too small to fit the requested radius, the corner curve
    /// and radius will be adjusted to fit.
    var cornerRadius: CGFloat
    /// Enforces a maximum size for the image. The default value is CGSize.zero. A zero width or
    /// height means the size is unconstrained on that dimension. If the image exceeds this size
    /// on either dimension, its size will be reduced proportionately (maintaining aspect ratio).
    var maximumSize: CGSize
    /// The layout size that is reserved for the image, inside which the image will be centered.
    /// The default value is CGSize.zero. The reservedLayoutSize width & height only affect the
    /// space reserved for the image and its positioning; it does not affect the image's size.
    /// A zero width or height means the default behavior is used for that dimension:
    ///     * Symbol images will be centered inside a predefined reservedLayoutSize that is
    ///       scaled with the content size category.
    ///     * Non-symbol images will use a reservedLayoutSize equal to the actual size of the
    ///       displayed image.
    /// This property is used for horizontal alignment of images across adjacent content views
    /// (even when the actual image widths may vary slightly), and/or to ensure the same height
    /// is reserved for different images across different content views (e.g. so the content view
    /// heights are consistent even when the actual image heights may vary slightly). The
    /// reservedLayoutSize.width is ignored by content views at Accessibility Dynamic Type
    /// sizes, and the reservedLayoutSize.height is ignored when using the special Accessibility
    /// Dynamic Type layout where text wraps around the image.
    var reservedLayoutSize: CGSize
    /// Prevents the image from inverting its colors when the accessibility setting is enabled.
    var accessibilityIgnoresInvertColors: Bool
    /// A special constant that can be set to the `reservedLayoutSize` width or height. This
    /// forces the system standard value that a symbol image would use for that dimension,
    /// even when the image is not a symbol image.
    static let standardDimension: CGFloat
    func hash(into hasher: inout Hasher)
    static func == (a: UIListContentConfiguration.ImageProperties, b: UIListContentConfiguration.ImageProperties) -> Bool
    var hashValue: Int { get }
  }
  struct TextProperties : Hashable {
    enum TextAlignment : Hashable {
      case natural
      case center
      case justified
      static func == (a: UIListContentConfiguration.TextProperties.TextAlignment, b: UIListContentConfiguration.TextProperties.TextAlignment) -> Bool
      func hash(into hasher: inout Hasher)
      var hashValue: Int { get }
    }
    enum TextTransform : Hashable {
      case none
      case uppercase
      case lowercase
      case capitalized
      static func == (a: UIListContentConfiguration.TextProperties.TextTransform, b: UIListContentConfiguration.TextProperties.TextTransform) -> Bool
      func hash(into hasher: inout Hasher)
      var hashValue: Int { get }
    }
    /// The font used for the text.
    var font: UIFont
    /// The color of the text.
    var color: UIColor
    /// Optional color transformer that is used to resolve the color. A nil value means
    /// the `color` is used as-is.
    var colorTransformer: UIConfigurationColorTransformer?
    /// Returns the resolved color, based on the `color` and `colorTransformer`.
    func resolvedColor() -> UIColor
    /// The alignment for the text.
    var alignment: UIListContentConfiguration.TextProperties.TextAlignment
    /// The line break mode to use for the text.
    var lineBreakMode: NSLineBreakMode
    /// The maximum number of lines for the text. 0 indicates the number of lines is unlimited.
    var numberOfLines: Int
    /// Whether the font size of the text is automatically adjusted when necessary to fit in the available width.
    var adjustsFontSizeToFitWidth: Bool
    /// When `adjustsFontSizeToFitWidth` is enabled, the smallest multiplier for the font size used to make the text fit.
    var minimumScaleFactor: CGFloat
    /// Whether the text is tightened before truncating.
    var allowsDefaultTighteningForTruncation: Bool
    /// Whether the font is automatically updated when the content size category changes.
    var adjustsFontForContentSizeCategory: Bool
    /// A transform that is applied to the text before it is displayed.
    var transform: UIListContentConfiguration.TextProperties.TextTransform
    func hash(into hasher: inout Hasher)
    static func == (a: UIListContentConfiguration.TextProperties, b: UIListContentConfiguration.TextProperties) -> Bool
    var hashValue: Int { get }
  }
  /// Returns the default configuration for a list cell.
  static func cell() -> UIListContentConfiguration
  /// Returns the default configuration for a list cell with subtitle text.
  static func subtitleCell() -> UIListContentConfiguration
  /// Returns the default configuration for a list cell with side-by-side value text.
  static func valueCell() -> UIListContentConfiguration
  /// Returns the default configuration for a plain list header.
  static func plainHeader() -> UIListContentConfiguration
  /// Returns the default configuration for a plain list footer.
  static func plainFooter() -> UIListContentConfiguration
  /// Returns the default configuration for a grouped list header.
  static func groupedHeader() -> UIListContentConfiguration
  /// Returns the default configuration for a grouped list footer.
  static func groupedFooter() -> UIListContentConfiguration
  /// Returns the default configuration for a sidebar list cell.
  static func sidebarCell() -> UIListContentConfiguration
  /// Returns the default configuration for a sidebar list cell with subtitle text.
  static func sidebarSubtitleCell() -> UIListContentConfiguration
  /// Returns the default configuration for an accompanied sidebar list cell.
  static func accompaniedSidebarCell() -> UIListContentConfiguration
  /// Returns the default configuration for an accompanied sidebar list cell with subtitle text.
  static func accompaniedSidebarSubtitleCell() -> UIListContentConfiguration
  /// Returns the default configuration for a sidebar list header.
  static func sidebarHeader() -> UIListContentConfiguration
  func makeContentView() -> UIView & UIContentView
  func updated(for state: UIConfigurationState) -> UIListContentConfiguration
  /// The image to display.
  var image: UIImage?
  /// Additional properties to configure the image.
  var imageProperties: UIListContentConfiguration.ImageProperties
  /// The primary text.
  var text: String?
  /// An attributed variant of the primary text, which supersedes the `text` and some properties of the `textConfiguration` if set.
  var attributedText: NSAttributedString?
  /// Additional properties to configure the primary text.
  var textProperties: UIListContentConfiguration.TextProperties
  /// The secondary text.
  var secondaryText: String?
  /// An attributed variant of the secondary text, which supersedes the `secondaryText` and some properties of the `secondaryTextConfiguration` if set.
  var secondaryAttributedText: NSAttributedString?
  /// Additional properties to configure the secondary text.
  var secondaryTextProperties: UIListContentConfiguration.TextProperties
  /// Whether the content view will preserve inherited layout margins from its superview on the horizontal and/or vertical axes.
  var axesPreservingSuperviewLayoutMargins: UIAxis
  /// The margins for the content to the edges of the content view. (When preserving superview layout margins on one or both axes, these are just minimum margins, as inherited margins may be larger.)
  var directionalLayoutMargins: NSDirectionalEdgeInsets
  /// When true, the text and secondary text will be positioned side-by-side if there is sufficient space. Otherwise, the text will be stacked in a vertical layout.
  var prefersSideBySideTextAndSecondaryText: Bool
  /// Padding between the image and text. Only applies when there is both an image and text.
  var imageToTextPadding: CGFloat
  /// Horizontal (minimum) padding between the text and secondary text. Only applies when there is both text and secondary text, and they are in a side-by-side layout.
  var textToSecondaryTextHorizontalPadding: CGFloat
  /// Vertical padding between the text and secondary text. Only applies when there is both text and secondary text, and they are in a stacked layout.
  var textToSecondaryTextVerticalPadding: CGFloat
  func hash(into hasher: inout Hasher)
  static func == (a: UIListContentConfiguration, b: UIListContentConfiguration) -> Bool
  var hashValue: Int { get }
}

@available(iOS 14.0, tvOS 14.0, *)
extension UIListContentConfiguration : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  var description: String { get }
  var debugDescription: String { get }
  var customMirror: Mirror { get }
}

@available(iOS 14.0, tvOS 14.0, *)
extension UIListContentConfiguration.ImageProperties : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  var description: String { get }
  var debugDescription: String { get }
  var customMirror: Mirror { get }
}

@available(iOS 14.0, tvOS 14.0, *)
extension UIListContentConfiguration.TextProperties : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  var description: String { get }
  var debugDescription: String { get }
  var customMirror: Mirror { get }
}

/// This configuration allows for fine grained control of separator appearance in a UICollectionView List section.
/// See UICollectionLayoutListConfiguration.separatorConfiguration
@available(iOS 14.5, *)
@available(tvOS, unavailable)
struct UIListSeparatorConfiguration : Hashable {
  enum Visibility : Hashable {
    /// UICollectionView list sections will resolve this to an appropriate value.
    case automatic
    case visible
    case hidden
    static func == (a: UIListSeparatorConfiguration.Visibility, b: UIListSeparatorConfiguration.Visibility) -> Bool
    func hash(into hasher: inout Hasher)
    var hashValue: Int { get }
  }
  /// The visibility of the top separator for the item that this configuration is applied to.
  var topSeparatorVisibility: UIListSeparatorConfiguration.Visibility
  /// The visibility of the bottom separator for the item that this configuration is applied to.
  var bottomSeparatorVisibility: UIListSeparatorConfiguration.Visibility
  /// Use the values from the edges in this constant to indicate to the consumer of a UIListSeparatorConfiguration that the value for that
  /// edge should be replaced with an appropriate inset.
  static let automaticInsets: NSDirectionalEdgeInsets
  /// Insets to apply to the top separator of the item that this configuration is applied to. The top and bottom values are ignored.
  /// Defaults to \c UIListSeparatorConfiguration.automaticInsets
  var topSeparatorInsets: NSDirectionalEdgeInsets
  /// Insets to apply to the bottom separator of the item that this configuration is applied to. The top and bottom values are ignored.
  /// Defaults to \c UIListSeparatorConfiguration.automaticInsets
  var bottomSeparatorInsets: NSDirectionalEdgeInsets
  /// The color to use for the separators for the item this configuration is applied to.
  var color: UIColor
  /// The color to use for the separators for the item this configuration is applied to, when the item is in a multiple selection group.
  var multipleSelectionColor: UIColor
  /// Initializes a list separator configuration with the appropriate defaults for the passed in list appearance.
  /// - Parameter listAppearance: The appearance of the list consuming this separator configuration
  init(listAppearance: UICollectionLayoutListConfiguration.Appearance)
  func hash(into hasher: inout Hasher)
  static func == (a: UIListSeparatorConfiguration, b: UIListSeparatorConfiguration) -> Bool
  var hashValue: Int { get }
}

@available(iOS 14.5, *)
@available(tvOS, unavailable)
extension UIListSeparatorConfiguration : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  var description: String { get }
  var debugDescription: String { get }
  var customMirror: Mirror { get }
}

@available(iOS 14.5, *)
@available(tvOS, unavailable)
extension UIListSeparatorConfiguration : _ObjectiveCBridgeable {
  func _bridgeToObjectiveC() -> __UIListSeparatorConfiguration
  static func _forceBridgeFromObjectiveC(_ source: __UIListSeparatorConfiguration, result: inout UIListSeparatorConfiguration?)
  static func _conditionallyBridgeFromObjectiveC(_ input: __UIListSeparatorConfiguration, result: inout UIListSeparatorConfiguration?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ _configuration: __UIListSeparatorConfiguration?) -> UIListSeparatorConfiguration
  typealias _ObjectiveCType = __UIListSeparatorConfiguration
}

@available(swift, deprecated: 4.2, message: "Use == operator instead.")
func UIOffsetEqualToOffset(_ offset1: UIOffset, _ offset2: UIOffset) -> Bool

@available(iOS 13.4, *)
enum UIPointerEffect {
  enum TintMode {
    case none
    case overlay
    case underlay
    static func == (a: UIPointerEffect.TintMode, b: UIPointerEffect.TintMode) -> Bool
    func hash(into hasher: inout Hasher)
    var hashValue: Int { get }
  }
  case automatic(UITargetedPreview)
  case highlight(UITargetedPreview)
  case lift(UITargetedPreview)
  case hover(UITargetedPreview, preferredTintMode: UIPointerEffect.TintMode = .overlay, prefersShadow: Bool = false, prefersScaledContent: Bool = true)
  var preview: UITargetedPreview { get }
}

@available(iOS 13.4, *)
extension UIPointerEffect : _ObjectiveCBridgeable {
  func _bridgeToObjectiveC() -> __UIPointerEffect
  static func _forceBridgeFromObjectiveC(_ input: __UIPointerEffect, result: inout UIPointerEffect?)
  static func _conditionallyBridgeFromObjectiveC(_ input: __UIPointerEffect, result: inout UIPointerEffect?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ internalEffect: __UIPointerEffect?) -> UIPointerEffect
  typealias _ObjectiveCType = __UIPointerEffect
}

@available(iOS 13.4, *)
extension UIPointerEffect.TintMode : Equatable {
}

@available(iOS 13.4, *)
extension UIPointerEffect.TintMode : Hashable {
}

@available(iOS 13.4, *)
enum UIPointerShape {
  case path(UIBezierPath)
  case roundedRect(CGRect, radius: CGFloat = UIPointerShape.defaultCornerRadius)
  case verticalBeam(length: CGFloat)
  case horizontalBeam(length: CGFloat)
  static let defaultCornerRadius: CGFloat
}

@available(iOS 13.4, *)
extension UIPointerShape : _ObjectiveCBridgeable {
  func _bridgeToObjectiveC() -> __UIPointerShape
  static func _forceBridgeFromObjectiveC(_ input: __UIPointerShape, result: inout UIPointerShape?)
  static func _conditionallyBridgeFromObjectiveC(_ input: __UIPointerShape, result: inout UIPointerShape?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ _effect: __UIPointerShape?) -> UIPointerShape
  typealias _ObjectiveCType = __UIPointerShape
}

@available(swift, obsoleted: 4.2, renamed: "UIPrintError.Code.jobFailed.rawValue")
let UIPrintJobFailedError: Int

@available(swift, obsoleted: 4.2, renamed: "UIPrintError.Code.noContent.rawValue")
let UIPrintNoContentError: Int

@available(swift, obsoleted: 4.2, renamed: "UIPrintError.Code.unknownImageFormat.rawValue")
let UIPrintUnknownImageFormatError: Int

@available(swift, obsoleted: 4.2, renamed: "UIPrintError.Code.notAvailable.rawValue")
let UIPrintingNotAvailableError: Int

@available(iOS 13.0, tvOS 13.0, *)
class UITableViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType> : NSObject, UITableViewDataSource where SectionIdentifierType : Hashable, ItemIdentifierType : Hashable {
  typealias CellProvider = (UITableView, IndexPath, ItemIdentifierType) -> UITableViewCell?
  init(tableView: UITableView, cellProvider: @escaping UITableViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>.CellProvider)
  func apply(_ snapshot: NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>, animatingDifferences: Bool = true, completion: (() -> Void)? = nil)
  func snapshot() -> NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>
  func itemIdentifier(for indexPath: IndexPath) -> ItemIdentifierType?
  func indexPath(for itemIdentifier: ItemIdentifierType) -> IndexPath?
  var defaultRowAnimation: UITableView.RowAnimation
  func numberOfSections(in tableView: UITableView) -> Int
  func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int
  func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell
  func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -> String?
  func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -> String?
  func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool
  func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath)
  func tableView(_ tableView: UITableView, canMoveRowAt indexPath: IndexPath) -> Bool
  func tableView(_ tableView: UITableView, moveRowAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath)
  func sectionIndexTitles(for tableView: UITableView) -> [String]?
  func tableView(_ tableView: UITableView, sectionForSectionIndexTitle title: String, at index: Int) -> Int
  func description() -> String
  override dynamic init()
}

@available(iOS 14.0, tvOS 14.0, *)
struct UIViewConfigurationState : UIConfigurationState, Hashable {
  var traitCollection: UITraitCollection
  var isDisabled: Bool
  var isHighlighted: Bool
  var isSelected: Bool
  var isFocused: Bool
  subscript(key: UIConfigurationStateCustomKey) -> AnyHashable?
  init(traitCollection: UITraitCollection)
  static func == (lhs: UIViewConfigurationState, rhs: UIViewConfigurationState) -> Bool
  func hash(into hasher: inout Hasher)
  var hashValue: Int { get }
}

@available(iOS 14.0, tvOS 14.0, *)
extension UIViewConfigurationState : _ObjectiveCBridgeable {
  func _bridgeToObjectiveC() -> __UIViewConfigurationState
  static func _forceBridgeFromObjectiveC(_ input: __UIViewConfigurationState, result: inout UIViewConfigurationState?)
  static func _conditionallyBridgeFromObjectiveC(_ input: __UIViewConfigurationState, result: inout UIViewConfigurationState?) -> Bool
  @_effects(readonly) static func _unconditionallyBridgeFromObjectiveC(_ _state: __UIViewConfigurationState?) -> UIViewConfigurationState
  typealias _ObjectiveCType = __UIViewConfigurationState
}

@available(iOS 14.0, tvOS 14.0, *)
extension UIViewConfigurationState : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {
  var description: String { get }
  var debugDescription: String { get }
  var customMirror: Mirror { get }
}

typealias _ColorLiteralType = UIColor

typealias _ImageLiteralType = UIImage

@available(swift 4)
protocol _UIKitNumericRawRepresentable : Comparable, RawRepresentable where Self.RawValue : Comparable, Self.RawValue : Numeric {
}

extension _UIKitNumericRawRepresentable {
  static func < (lhs: Self, rhs: Self) -> Bool
  static func + (lhs: Self, rhs: Self.RawValue) -> Self
  static func + (lhs: Self.RawValue, rhs: Self) -> Self
  static func - (lhs: Self, rhs: Self.RawValue) -> Self
  static func - (lhs: Self, rhs: Self) -> Self.RawValue
  static func += (lhs: inout Self, rhs: Self.RawValue)
  static func -= (lhs: inout Self, rhs: Self.RawValue)
}

extension UIPasteboard {
  /// Detects patterns in the first pasteboard item.
  ///
  /// - Parameters:
  ///   - patterns: Detect only these patterns.
  ///   - completionHandler: Receives which patterns were detected, or an error.
  @available(iOS 14.0, *)
  func detectPatterns(for patterns: Set<UIPasteboard.DetectionPattern>, completionHandler: @escaping (Result<Set<UIPasteboard.DetectionPattern>, Error>) -> ())
  /// Detects patterns in the specified pasteboard items.
  ///
  /// - Parameters:
  ///   - patterns: Detect only these patterns.
  ///   - itemSet: Specifies which pasteboard items by their position. Nil means all items.
  ///   - completionHandler: Receives which patterns were detected per item specified,
  ///                        or an error.
  @available(iOS 14.0, *)
  func detectPatterns(for patterns: Set<UIPasteboard.DetectionPattern>, inItemSet itemSet: IndexSet?, completionHandler: @escaping (Result<[Set<UIPasteboard.DetectionPattern>], Error>) -> ())
  /// Detects patterns and corresponding values in the first pasteboard item.
  ///
  /// - Parameters:
  ///   - patterns: Detect only these patterns.
  ///   - completionHandler: Receives which patterns and values were detected, or an error.
  @available(iOS 14.0, *)
  func detectValues(for patterns: Set<UIPasteboard.DetectionPattern>, completionHandler: @escaping (Result<[UIPasteboard.DetectionPattern : Any], Error>) -> ())
  /// Detects patterns and corresponding values in the specified pasteboard items.
  ///
  /// - Parameters:
  ///   - patterns: Detect only these patterns.
  ///   - itemSet: Specifies which pasteboard items by their position. Nil means all items.
  ///   - completionHandler: Receives which patterns and values were detected per item specified,
  ///                        or an error.
  @available(iOS 14.0, *)
  func detectValues(for patterns: Set<UIPasteboard.DetectionPattern>, inItemSet itemSet: IndexSet?, completionHandler: @escaping (Result<[[UIPasteboard.DetectionPattern : Any]], Error>) -> ())
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewCell {
  @available(iOS 14.0, tvOS 14.0, *)
  var contentConfiguration: UIContentConfiguration?
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewListCell {
  @available(iOS 14.0, tvOS 14.0, *)
  func defaultContentConfiguration() -> UIListContentConfiguration
}

@available(iOS 14.0, tvOS 14.0, *)
extension UITableViewCell {
  @available(iOS 14.0, tvOS 14.0, *)
  var contentConfiguration: UIContentConfiguration?
  @available(iOS 14.0, tvOS 14.0, *)
  func defaultContentConfiguration() -> UIListContentConfiguration
}

@available(iOS 14.0, tvOS 14.0, *)
extension UITableViewHeaderFooterView {
  @available(iOS 14.0, tvOS 14.0, *)
  var contentConfiguration: UIContentConfiguration?
  @available(iOS 14.0, tvOS 14.0, *)
  func defaultContentConfiguration() -> UIListContentConfiguration
}

@available(iOS 14.0, tvOS 14.0, *)
extension UIListContentView : UIContentView {
  @available(iOS 14.0, tvOS 14.0, *)
  var configuration: UIContentConfiguration
  @available(iOS 14.0, tvOS 14.0, *)
  convenience init(configuration: UIListContentConfiguration)
}

extension UIBarButtonItem {
  @available(iOS 14.0, *)
  convenience init(systemItem: UIBarButtonItem.SystemItem, primaryAction: UIAction? = nil, menu: UIMenu? = nil)
  @available(iOS 14.0, *)
  convenience init(title: String? = nil, image: UIImage? = nil, primaryAction: UIAction? = nil, menu: UIMenu? = nil)
}

extension UIControl {
  @available(iOS 14.0, *)
  func enumerateEventHandlers(_ iterator: (UIAction?, (Any?, Selector)?, UIControl.Event, inout Bool) -> Void)
}

extension UIButton {
  @available(iOS 14.0, *)
  convenience init(type buttonType: UIButton.ButtonType = .system, primaryAction: UIAction?)
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewCell {
  @available(iOS 14.0, tvOS 14.0, *)
  var backgroundConfiguration: UIBackgroundConfiguration?
}

@available(iOS 14.0, tvOS 14.0, *)
extension UITableViewCell {
  @available(iOS 14.0, tvOS 14.0, *)
  var backgroundConfiguration: UIBackgroundConfiguration?
}

@available(iOS 14.0, tvOS 14.0, *)
extension UITableViewHeaderFooterView {
  @available(iOS 14.0, tvOS 14.0, *)
  var backgroundConfiguration: UIBackgroundConfiguration?
}

extension UIEdgeInsets : Equatable {
  @_transparent static func == (lhs: UIEdgeInsets, rhs: UIEdgeInsets) -> Bool
}

@available(iOS 11.0, tvOS 11.0, watchOS 4.0, *)
extension NSDirectionalEdgeInsets : Equatable {
  @_transparent static func == (lhs: NSDirectionalEdgeInsets, rhs: NSDirectionalEdgeInsets) -> Bool
}

extension UIOffset : Equatable {
  @_transparent static func == (lhs: UIOffset, rhs: UIOffset) -> Bool
}

extension UIFloatRange : Equatable {
  @_transparent static func == (lhs: UIFloatRange, rhs: UIFloatRange) -> Bool
}

extension UIEdgeInsets : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

@available(iOS 11.0, tvOS 11.0, watchOS 4.0, *)
extension NSDirectionalEdgeInsets : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

extension UIOffset : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

extension UIFloatRange : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

extension UIFont.Weight : _UIKitNumericRawRepresentable {
}

extension UILayoutPriority : _UIKitNumericRawRepresentable {
}

extension UIWindow.Level : _UIKitNumericRawRepresentable {
}

extension UIActionSheet {
  convenience init(title: String?, delegate: UIActionSheetDelegate?, cancelButtonTitle: String?, destructiveButtonTitle: String?, otherButtonTitles firstButtonTitle: String, _ moreButtonTitles: String...)
}

extension UIAlertView {
  convenience init(title: String, message: String, delegate: UIAlertViewDelegate?, cancelButtonTitle: String?, otherButtonTitles firstButtonTitle: String, _ moreButtonTitles: String...)
}

extension UIView : __DefaultCustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "UIView._defaultCustomPlaygroundQuickLook will be removed in a future Swift version")
  var _defaultCustomPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension UIColor : _ExpressibleByColorLiteral {
  @nonobjc required convenience init(_colorLiteralRed red: Float, green: Float, blue: Float, alpha: Float)
}

extension UIImage : _ExpressibleByImageLiteral {
  required convenience init(imageLiteralResourceName name: String)
}

extension UIFont.TextStyle {
  @available(iOS 11.0, watchOS 4.0, tvOS 11.0, *)
  var metrics: UIFontMetrics { get }
}

extension UIContentSizeCategory {
  @available(iOS 11.0, tvOS 11.0, *)
  var isAccessibilityCategory: Bool { get }
  @available(iOS 11.0, tvOS 11.0, *)
  static func < (left: UIContentSizeCategory, right: UIContentSizeCategory) -> Bool
  @available(iOS 11.0, tvOS 11.0, *)
  static func <= (left: UIContentSizeCategory, right: UIContentSizeCategory) -> Bool
  @available(iOS 11.0, tvOS 11.0, *)
  static func > (left: UIContentSizeCategory, right: UIContentSizeCategory) -> Bool
  @available(iOS 11.0, tvOS 11.0, *)
  static func >= (left: UIContentSizeCategory, right: UIContentSizeCategory) -> Bool
}

@available(iOS 11.0, tvOS 11.0, *)
extension UIFocusEnvironment {
  @available(iOS 11.0, tvOS 11.0, *)
  func contains(_ environment: UIFocusEnvironment) -> Bool
}

@available(iOS 11.0, tvOS 11.0, *)
extension UIFocusItem {
  @available(iOS 11.0, tvOS 11.0, *)
  var isFocused: Bool { get }
}

@available(iOS 11.0, *)
extension UIDragDropSession {
  @available(iOS 11.0, *)
  func canLoadObjects<T>(ofClass: T.Type) -> Bool where T : _ObjectiveCBridgeable, T._ObjectiveCType : NSItemProviderReading
}

@available(iOS 11.0, *)
extension UIDropSession {
  @available(iOS 11.0, *)
  func loadObjects<T>(ofClass: T.Type, completion: @escaping ([T]) -> Void) -> Progress where T : _ObjectiveCBridgeable, T._ObjectiveCType : NSItemProviderReading
}

@available(iOS 11.0, *)
extension UIPasteConfiguration {
  @available(iOS 11.0, *)
  convenience init<T>(forAccepting _: T.Type) where T : _ObjectiveCBridgeable, T._ObjectiveCType : NSItemProviderReading
  @available(iOS 11.0, *)
  func addTypeIdentifiers<T>(forAccepting aClass: T.Type) where T : _ObjectiveCBridgeable, T._ObjectiveCType : NSItemProviderReading
}

extension UIPasteboard {
  @available(iOS 11.0, *)
  func setObjects<T>(_ objects: [T]) where T : _ObjectiveCBridgeable, T._ObjectiveCType : NSItemProviderWriting
  @available(iOS 11.0, *)
  func setObjects<T>(_ objects: [T], localOnly: Bool, expirationDate: Date?) where T : _ObjectiveCBridgeable, T._ObjectiveCType : NSItemProviderWriting
}

extension UIApplicationDelegate {
  @_alwaysEmitIntoClient static func main()
}

extension UIStoryboard {
  @available(iOS 13.0, tvOS 13.0, *)
  func instantiateInitialViewController<ViewController>(creator: ((NSCoder) -> ViewController?)? = nil) -> ViewController? where ViewController : UIViewController
  @available(iOS 13.0, tvOS 13.0, *)
  func instantiateViewController<ViewController>(identifier: String, creator: ((NSCoder) -> ViewController?)? = nil) -> ViewController where ViewController : UIViewController
}

extension UIAccessibilityTraits : OptionSet {
  typealias ArrayLiteralElement = UIAccessibilityTraits
  typealias Element = UIAccessibilityTraits
}

extension UITextDirection {
  static func storage(_ direction: UITextStorageDirection) -> UITextDirection
  static func layout(_ direction: UITextLayoutDirection) -> UITextDirection
}

@available(iOS 13.0, *)
extension UICommand {
  /// Initializes a keyless command with extra properties.
  ///
  /// - Parameters:
  ///   - title: Short display title. This should be localized.
  ///   - image: Image that can appear next to the command, if any.
  ///   - action: Action to execute on choosing this command.
  ///   - propertyList: Property list object to distinguish commands, if needed.
  ///   - alternates: Alternates that differ in modifier flags, if needed.
  ///   - discoverabilityTitle: Elaborated title, if any.
  ///   - attributes: Command attributes.
  ///   - state: State that can appear next to the command.
  convenience init(title: String = "", image: UIImage? = nil, action: Selector, propertyList: Any? = nil, alternates: [UICommandAlternate] = [], discoverabilityTitle: String? = nil, attributes: UIMenuElement.Attributes = [], state: UIMenuElement.State = .off)
}

@available(iOS 13.0, *)
extension UIKeyCommand {
  /// Initializes a key command with extra properties.
  ///
  /// - Parameters:
  ///   - title: Short display title. This should be localized.
  ///   - action: Action to execute on choosing this command.
  ///   - input: Keys that must be pressed to choose this command.
  ///   - modifierFlags: Bit mask of key modifier flags to choose this command.
  ///   - propertyList: Property list object to distinguish commands, if needed.
  ///   - alternates: Alternates that differ in modifier flags, if needed.
  ///   - image: Image that can appear next to the command, if any.
  ///   - discoverabilityTitle: Elaborated title, if any.
  ///   - isEnabled: Whether to enable or disable the command.
  ///   - state: State that can appear next to the command.
  convenience init(title: String = "", image: UIImage? = nil, action: Selector, input: String, modifierFlags: UIKeyModifierFlags = [], propertyList: Any? = nil, alternates: [UICommandAlternate] = [], discoverabilityTitle: String? = nil, attributes: UIMenuElement.Attributes = [], state: UIMenuElement.State = .off)
}

@available(iOS 13.0, tvOS 14.0, *)
extension UIAction {
  /// Creates a UIAction with the given arguments.
  ///
  /// - Parameters:
  ///   - title: The action's title.
  ///   - image: Image to be displayed alongside the action's title.
  ///   - identifier: Action's unique identifier. Pass nil to use an auto-generated identifier.
  ///   - discoverabilityTitle: Elaborated title, if any.
  ///   - attributes: Action's attributes.
  ///   - state: State that can appear next to the action.
  ///   - handler: Handler block. Called when the user selects the action.
  convenience init(title: String = "", image: UIImage? = nil, identifier: UIAction.Identifier? = nil, discoverabilityTitle: String? = nil, attributes: UIMenuElement.Attributes = [], state: UIMenuElement.State = .off, handler: @escaping UIActionHandler)
}

@available(iOS 13.0, tvOS 14.0, *)
extension UIMenu {
  /// Creates a UIMenu with the given arguments.
  ///
  /// - Parameters:
  ///   - title: The menu's title.
  ///   - image: Image to be displayed alongside the menu's title.
  ///   - identifier: The menu's unique identifier. Pass nil to use an auto-generated identifier.
  ///   - options: The menu's options.
  ///   - children: The menu's sub-elements and sub-menus.
  convenience init(title: String = "", image: UIImage? = nil, identifier: UIMenu.Identifier? = nil, options: UIMenu.Options = [], children: [UIMenuElement] = [])
}

@available(iOS 13.0, tvOS 14.0, *)
extension UIMenuBuilder {
  /// Fetch the identified command.
  ///
  /// - Parameters:
  ///   - action: The action of the command to find.
  ///   - propertyList: Property list object to distinguish commands, if needed.
  /// - Returns: The command with the given action and property list, or `nil` if no such command.
  func command(for action: Selector, propertyList: Any? = nil) -> UICommand?
}

@available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension UIImage {
  var baselineOffsetFromBottom: CGFloat? { get }
}

@available(iOS 13.4, *)
extension UIPointerStyle {
  convenience init(effect: UIPointerEffect, shape: UIPointerShape? = nil)
  convenience init(shape: UIPointerShape, constrainedAxes: UIAxis = [])
}

@available(iOS 13.4, *)
extension UIPointerRegion {
  convenience init(rect: CGRect, identifier: AnyHashable? = nil)
  var identifier: AnyHashable? { get }
}

@available(iOS 13.4, *)
extension UIButton {
  typealias PointerStyleProvider = (UIButton, UIPointerEffect, UIPointerShape) -> UIPointerStyle?
  var pointerStyleProvider: UIButton.PointerStyleProvider?
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionView {
  struct CellRegistration<Cell, Item> where Cell : UICollectionViewCell {
    typealias Handler = (Cell, IndexPath, Item) -> Void
    init(handler: @escaping UICollectionView.CellRegistration<Cell, Item>.Handler)
    init(cellNib: UINib, handler: @escaping UICollectionView.CellRegistration<Cell, Item>.Handler)
  }
  struct SupplementaryRegistration<Supplementary> where Supplementary : UICollectionReusableView {
    typealias Handler = (Supplementary, String, IndexPath) -> Void
    init(elementKind: String, handler: @escaping UICollectionView.SupplementaryRegistration<Supplementary>.Handler)
    init(supplementaryNib: UINib, elementKind: String, handler: @escaping UICollectionView.SupplementaryRegistration<Supplementary>.Handler)
  }
  func dequeueConfiguredReusableCell<Cell, Item>(using registration: UICollectionView.CellRegistration<Cell, Item>, for indexPath: IndexPath, item: Item?) -> Cell where Cell : UICollectionViewCell
  func dequeueConfiguredReusableSupplementary<Supplementary>(using registration: UICollectionView.SupplementaryRegistration<Supplementary>, for indexPath: IndexPath) -> Supplementary where Supplementary : UICollectionReusableView
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewListCell {
  @available(iOS 14.0, tvOS 14.0, *)
  var accessories: [UICellAccessory]
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewCompositionalLayout {
  static func list(using configuration: UICollectionLayoutListConfiguration) -> UICollectionViewCompositionalLayout
}

@available(iOS 14.0, tvOS 14.0, *)
extension NSCollectionLayoutSection {
  static func list(using configuration: UICollectionLayoutListConfiguration, layoutEnvironment: NSCollectionLayoutEnvironment) -> NSCollectionLayoutSection
}

extension IndexPath {
  /// Initialize for use with `UITableView` or `UICollectionView`.
  init(row: Int, section: Int)
  /// The section of this index path, when used with `UITableView`.
  ///
  /// - precondition: The index path must have exactly two elements.
  var section: Int
  /// The row of this index path, when used with `UITableView`.
  ///
  /// - precondition: The index path must have exactly two elements.
  var row: Int
}

extension IndexPath {
  /// Initialize for use with `UITableView` or `UICollectionView`.
  init(item: Int, section: Int)
  /// The item of this index path, when used with `UICollectionView`.
  ///
  /// - precondition: The index path must have exactly two elements.
  var item: Int
}

extension URLResourceValues {
  /// Returns a dictionary of UIImage objects keyed by size.
  @available(iOS 8.0, *)
  var thumbnailDictionary: [URLThumbnailDictionaryItem : UIImage]? { get }
}

extension UIEdgeInsets : _ObjectiveCBridgeable {
  func _bridgeToObjectiveC() -> NSValue
  static func _forceBridgeFromObjectiveC(_ source: NSValue, result: inout UIEdgeInsets?)
  static func _conditionallyBridgeFromObjectiveC(_ source: NSValue, result: inout UIEdgeInsets?) -> Bool
  static func _unconditionallyBridgeFromObjectiveC(_ source: NSValue?) -> UIEdgeInsets
  typealias _ObjectiveCType = NSValue
}

@available(iOS 11.0, tvOS 11.0, watchOS 4.0, *)
extension NSDirectionalEdgeInsets : _ObjectiveCBridgeable {
  func _bridgeToObjectiveC() -> NSValue
  static func _forceBridgeFromObjectiveC(_ source: NSValue, result: inout NSDirectionalEdgeInsets?)
  static func _conditionallyBridgeFromObjectiveC(_ source: NSValue, result: inout NSDirectionalEdgeInsets?) -> Bool
  static func _unconditionallyBridgeFromObjectiveC(_ source: NSValue?) -> NSDirectionalEdgeInsets
  typealias _ObjectiveCType = NSValue
}

extension UIOffset : _ObjectiveCBridgeable {
  func _bridgeToObjectiveC() -> NSValue
  static func _forceBridgeFromObjectiveC(_ source: NSValue, result: inout UIOffset?)
  static func _conditionallyBridgeFromObjectiveC(_ source: NSValue, result: inout UIOffset?) -> Bool
  static func _unconditionallyBridgeFromObjectiveC(_ source: NSValue?) -> UIOffset
  typealias _ObjectiveCType = NSValue
}

@available(iOS 14.0, tvOS 14.0, *)
extension UICollectionViewCell {
  @available(iOS 14.0, tvOS 14.0, *)
  @objc(_bridgedConfigurationState) dynamic var configurationState: UICellConfigurationState { get }
  @available(iOS 14.0, tvOS 14.0, *)
  @objc(_bridgedUpdateConfigurationUsingState:) dynamic func updateConfiguration(using state: UICellConfigurationState)
}

@available(iOS 14.0, tvOS 14.0, *)
extension UITableViewCell {
  @available(iOS 14.0, tvOS 14.0, *)
  @objc(_bridgedConfigurationState) dynamic var configurationState: UICellConfigurationState { get }
  @available(iOS 14.0, tvOS 14.0, *)
  @objc(_bridgedUpdateConfigurationUsingState:) dynamic func updateConfiguration(using state: UICellConfigurationState)
}

@available(iOS 14.0, tvOS 14.0, *)
extension UITableViewHeaderFooterView {
  @available(iOS 14.0, tvOS 14.0, *)
  @objc(_bridgedConfigurationState) dynamic var configurationState: UIViewConfigurationState { get }
  @available(iOS 14.0, tvOS 14.0, *)
  @objc(_bridgedUpdateConfigurationUsingState:) dynamic func updateConfiguration(using state: UIViewConfigurationState)
}

@available(swift, obsoleted: 4.2, renamed: "UIPrintError.Code.notAvailable.rawValue")
var UIPrintingNotAvailableError: Int

@available(swift, obsoleted: 4.2, renamed: "UIPrintError.Code.noContent.rawValue")
var UIPrintNoContentError: Int

@available(swift, obsoleted: 4.2, renamed: "UIPrintError.Code.unknownImageFormat.rawValue")
var UIPrintUnknownImageFormatError: Int

@available(swift, obsoleted: 4.2, renamed: "UIPrintError.Code.jobFailed.rawValue")
var UIPrintJobFailedError: Int

